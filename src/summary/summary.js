
//객체를 원소로 같는 배열은 map()내장함수 메서드를 사용해서 컴포넌트의 요소들이 변환 가능하도록 해준다

// 삭제는 입력받은(삭제버튼) id에 해당하는 것을 지우려하기에 그 id를 받는 함수가 클릭될때 실행하기 위해서 onClick={}안에 콜백함수 형태로 onRemove()를 호출 해주어야 한다. 그냥 onRemove를 호출하게 되면 렌더링되는 시점에 삭제가 바로 되어버린다(클릭 하지도 않았는데!!)


// 항목 렌더링 정리
// 배열 항목에서 추가할땐 새로운 항목 객체형태로 만들어서 스프레드나 concat으로 추가
// 배열 항목에서 삭제할땐 선택된 id값이 아닌것만 filter함수 사용해서 상태 갱신해주기
// 배열 항목에서 수정할땐 선택된 id값이 변해야하기때문에 map을 사용해서 각 항목들중 선택된 id값이면 수정할 사항 업데이트해준다(상태 반전시키기 등)


// useEffect(() => { // 마운트
//   console.log('컴포넌트가 화면에 나타남');
//   // props로 받은 값을 이 컴포넌트의 state로 설정할때
//   // REST API
//   // D3,video.js
//   // setTimeout, setInterval
//   return () => { // 언마운트
//     console.log('컴포넌트가 화면에 사라짐');
//     // clearTimeout, clearInterval
//   }
// },[])


// useRef()
// 컴포넌트가 리렌더링될때 유지하고 싶은값을 제어하고 싶을때 useRef훅을 사용하면 된다. 왜냐하면 일반 변수는 컴포넌트라 마운팅될때마다 초기화가 되어버리기에 값을 다시 설정해줘야하는 불편한점이있는데 그걸 방지할수 있게된다.
// 값을 useRef로 관리하는 경우 : (setTimout, seInterval)의 id, 외부라이브러리를 사용하여 생성된 인스턴스, Scroll의 위치 등등


// useMemo()
// 내가 지정한 상태가 아닌 것까지 불필요한 리렌더링을 되는걸 방지하기 위해 useMemo hook을 사용
// useMemo는 특정값이 바뀔때만 특정함수를 실행해서 연산을 하도록 처리하고, 원하는 값이 바뀌지 않았다면, 리렌더링시 그 전에 있던값을 기억해서 재사용하게 하기위함이다.
// 뎁스안의 값이 바뀌여야만, 콜백함수안의 함수를 실행해주겠다는 것이다.
// useMemo는 최적화하는 작업이다.  


// useCallback()
// useCallback hook는 만든 함수를 재사용할때 유용하게 사용한다.
// 함수 내부에서 의존하고있는 값(사용하고있는값)을 확인해 두번째 인자에 deps로 넣어준다.
// 제대로 deps에 상태를 지정하지 않은다면, 해당 함수내부에서 해당 상태들을 참조하게 될때 최신상태를 참조하지않고 이전(처음 컴포넌트가 만들어질 때)값에 참조하는 의도치않은 일이 발생할수있다.


// React.memo()
// 여기서 추가로 짚고 넘어가야 할점이 있는데, 전달받은 props값이 바뀌지 않았을땐 리렌더링을 방지하도록 해줘야하는게 맞는데 여기서 UserList와 User에는 users라는 props를 받고 있고 이 값은 부모컴포넌트인 App컴포넌트에서 onRemove, onToggle함수의 종속성 배열로 참조되어있는걸 볼 수 있다. 그렇게 되면 종속성 배열에 있는 users배열의 상태가 바뀌게되면 props로 전달한 함수(onRemove,onToggle)또한 바뀌게 되므로 선택한 user가 아닌 다른 user또한 전부 리렌더링이 되어버린다. 이를해결하기 위해선, props로 전달하는 함수들(onCreate,onRemove,onToggle)에서 기존 users를 종속성 배열로 참조해선 안된다. 그 대신 해당 함수 내부에 useState 변경함수를 업데이트 하는것이다.  

// ex) onCreate함수는 내부에 있는 setUsers([...users, newUser]) -> setUsers((users) => ([...users, newUser])) 이런식으로 조정하면 된다. 이러면 setUsers에 등록한 콜백함수의 파라미터로 최신 users가 조회될수 있기 때문에 굳이 종속성 배열로 users넣지 않아도 되는것이다. -> React.memo를 활용한 최적화 완료

// 정리

// 연산된 값(특정값)을 재사용하기 위해 사용하는 hook => useMemo
// 특정 함수를 재사용하기 위해 사용하는 hook => useCallback
// 부모컴포넌트의 렌더링된 결과물을 자식에서 재사용하기 위해 사용 => React.memo